"use strict";
const tslib_1 = require("tslib");
const mock_require_1 = tslib_1.__importDefault(require("mock-require"));
const path_1 = tslib_1.__importDefault(require("path"));
const resolve_from_1 = tslib_1.__importDefault(require("resolve-from"));
const resolve_global_1 = tslib_1.__importDefault(require("resolve-global"));
const pluginMarker = Symbol('pluginMarker');
class TSTLPlugin {
    constructor(ts, languageService, project, serverHost) {
        this.ts = ts;
        this.languageService = languageService;
        this.project = project;
        this.serverHost = serverHost;
    }
    log(message) {
        this.project.log(`[typescript-tstl-plugin] ${this.project.getProjectName()}: ${message}`);
    }
    update() {
        this.log('Updating project');
        if (!(this.project instanceof this.ts.server.ConfiguredProject))
            return;
        const configFilePath = this.project.getConfigFilePath();
        const config = this.ts.parseJsonSourceFileConfigFileContent(this.ts.readJsonConfigFile(configFilePath, this.serverHost.readFile), this.serverHost, path_1.default.dirname(configFilePath), undefined, configFilePath);
        this.parsedCommandLine = this.tstl.updateParsedConfigFile(config);
    }
    get tstl() {
        if (!this._tstl) {
            const resolved = resolve_from_1.default.silent(this.project.getCurrentDirectory(), 'typescript-to-lua') ||
                resolve_global_1.default.silent('typescript-to-lua') ||
                'typescript-to-lua';
            this.log(`Loading typescript-to-lua from "${resolved}"`);
            // eslint-disable-next-line @typescript-eslint/no-require-imports
            this._tstl = require(resolved);
        }
        return this._tstl;
    }
    wrap() {
        this.log('Wrapping language service');
        this.update();
        const intercept = Object.create(null);
        intercept[pluginMarker] = this;
        intercept.getSemanticDiagnostics = this.getSemanticDiagnostics.bind(this);
        return new Proxy(this.languageService, {
            get: (target, property) => intercept[property] || target[property],
        });
    }
    getSemanticDiagnostics(fileName) {
        const diagnostics = this.languageService.getSemanticDiagnostics(fileName);
        const program = this.languageService.getProgram();
        if (!program)
            return diagnostics;
        const sourceFile = program.getSourceFile(fileName);
        if (sourceFile && !sourceFile.isDeclarationFile) {
            diagnostics.push(...this.getTstlDiagnostics(program, sourceFile));
        }
        return diagnostics;
    }
    getTstlDiagnostics(program, sourceFile) {
        if (this.parsedCommandLine?.raw.tstl != null) {
            const programOptions = program.getCompilerOptions();
            Object.assign(programOptions, this.parsedCommandLine.options);
            programOptions.noEmit = true;
            programOptions.noEmitOnError = false;
            programOptions.declaration = false;
            programOptions.declarationMap = false;
            programOptions.emitDeclarationOnly = false;
            try {
                let diagnostics;
                // >=0.35.0
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                if (this.tstl.getProgramTranspileResult !== undefined) {
                    ({ diagnostics } = this.tstl.getProgramTranspileResult(this.serverHost, () => { }, {
                        program,
                        sourceFiles: [sourceFile],
                    }));
                }
                // >=0.19.0
                if (this.tstl.transpile !== undefined) {
                    ({ diagnostics } = this.tstl.transpile({ program, sourceFiles: [sourceFile] }));
                }
                if (diagnostics === undefined) {
                    throw new Error(`Unsupported TypeScriptToLua version: ${this.tstl.version}`);
                }
                return diagnostics.map((diag) => ({ ...diag, code: undefined }));
            }
            catch (error) {
                this.log(`Error during transpilation: ${error.stack}`);
            }
        }
        return [];
    }
}
const init = ({ typescript }) => {
    mock_require_1.default('typescript', typescript);
    return {
        create({ languageService, project, serverHost }) {
            const oldPlugin = languageService[pluginMarker];
            if (oldPlugin) {
                oldPlugin.update();
                return languageService;
            }
            const plugin = new TSTLPlugin(typescript, languageService, project, serverHost);
            return plugin.wrap();
        },
    };
};
module.exports = init;
//# sourceMappingURL=index.js.map